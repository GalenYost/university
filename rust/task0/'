use std::io::stdin;
use std::collections::HashMap;

pub type Callback = Box<dyn FnMut(InputValue) -> ()>;

#[derive(Eq, Hash, PartialEq)]
struct Bind {
    key: String,
    description: String,
}

pub struct InputBuffer {
    options: HashMap<Bind, Option<Callback>>,
}

#[derive(Debug, Eq, PartialEq)]
pub enum InputType {
    Text,
    Number,
}

#[derive(Debug, Eq, PartialEq)]
pub enum InputValue {
    Text(String),
    Number(usize),
}

impl std::fmt::Display for InputValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            InputValue::Text(text) => write!(f, "{}", text),
            InputValue::Number(num) => write!(f, "{}", num.to_string())
        }
    }
}

fn read_input() -> Result<String, String> {
    println!("Input: ");
    let mut inp_buf = String::new();
    stdin().read_line(&mut inp_buf).map_err(|e| format!("fail reading input: {}", e))?;
    Ok(inp_buf.trim().to_string())
}

pub fn read_input_and_cast_value(input_type: InputType) -> Result<InputValue, String> {
    let input = read_input()?;
    Ok(match input_type {
        InputType::Text => InputValue::Text(input),
        InputType::Number => {
            let parsed: usize = input.parse().map_err(|e| format!("invalid number input: {}", e))?;
            InputValue::Number(parsed)
        },
    })
}

impl InputBuffer {
    pub fn new() -> Self {
        Self {
            options: HashMap::new(),
        }
    }

    pub fn prompt(&self) -> () {
        for (bind, _) in self.options.iter() {
            println!("{} - {}", bind.key, bind.description);
        }
    }

    pub fn bind<F>(&mut self, key: &str, description: &str, callback: Option<F>) -> &mut Self 
    where
        F: FnMut(InputValue) + 'static
    {
        self.options.insert(Bind {
            key: key.into(),
            description: description.into()
        }, Box::new(callback));
        self
    }

    pub fn read_input_and_call(&mut self, input_type: InputType) -> Result<(), String> {
        let key: String = read_input()?;

        for (bind, callback) in self.options.iter_mut() {
            if bind.key == key {
                let value = read_input_and_cast_value(input_type)?;
                callback(value);
                return Ok(())
            }
        }
        
        Err("invalid key input".into())
    }
}
